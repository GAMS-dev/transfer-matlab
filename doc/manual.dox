/** \page API_MATLAB_GAMSTRANSFER_MANUAL Manual

\tableofcontents

\section MATLAB_GT_DESIGN GAMS Transfer Design

\subsection GAMSTRANSFER_MATLAB_INDEXEDGDX Indexed GDX

Two different GDX interfaces exist and are both supported by the Matlab version
of GAMS Transfer: (default) GDX and indexed GDX (also called IDX). These two
interfaces mainly differ in the characterization of symbols:
- Default GDX: Symbol \ref Matlab::GAMSTransfer::Symbol::dimension "dimension"
  and shape are defined by \ref Matlab::GAMSTransfer::Symbol::domain "domain".
  Symbol \ref Matlab::GAMSTransfer::Symbol::records "records" are identified by
  UELs (see also \ref MATLAB_GT_DESIGN_UEL).
- Indexed GDX: Symbol \ref Matlab::GAMSTransfer::Symbol::dimension "dimension"
  and shape are defined by \ref Matlab::GAMSTransfer::Symbol::size "size". UELs
  do not exist. Symbol \ref Matlab::GAMSTransfer::Symbol::records "records" are
  identified by numerical indices.

The mode -- default or indexed -- can be specified when creating a \ref
Matlab::GAMSTransfer::Container "Container" and cannot be changed thereafter,
e.g.:
\code{.matlab}
m = Container('indexed', true);
\endcode

In indexed mode, pass the shape of the symbol instead of the domain to the
constructor:
\code{.matlab}
d = Parameter(m, 'd', [2, 3], 'description', 'distance in thousands of miles');
\endcode

\note The only supported symbols in indexed mode are \ref
Matlab::GAMSTransfer::Parameter "Parameter".

\note In indexed mode it is not possible to set the property \ref
Matlab::GAMSTransfer::Symbol::domain "domain" or using the UEL related methods
(e.g. \ref Matlab::GAMSTransfer::Symbol::getUELs "getUELs" or \ref
Matlab::GAMSTransfer::Symbol::setUELs "setUELs"), while in default mode the
property \ref Matlab::GAMSTransfer::Symbol::size "size" cannot be set and is
inferred from by the domain.

\subsection MATLAB_GT_DESIGN_CONTAINERS Container Types

GAMS Transfer offers two different container types: \ref
Matlab::GAMSTransfer::Container "Container" and \ref
Matlab::GAMSTransfer::ConstContainer "ConstContainer". The latter differs from
the former in that it is read only. After creation, data cannot be altered
anymore. This allows to use internal operations with better runtime performance.
Being read only, however, implies that many features of a \ref
Matlab::GAMSTransfer::Container "Container" are not available in a \ref
Matlab::GAMSTransfer::ConstContainer "ConstContainer". Hence, choose \ref
Matlab::GAMSTransfer::ConstContainer "ConstContainer", when performance is key.

Further differences are:
- \ref Matlab::GAMSTransfer::ConstContainer "ConstContainer" currently does not
  support writing to GDX.
- \ref Matlab::GAMSTransfer::ConstContainer "ConstContainer" symbols are
  structs, not objects.
- \ref Matlab::GAMSTransfer::ConstContainer "ConstContainer" symbols are linked
  by domain names, not \ref Matlab::GAMSTransfer::Set "Set" object references.
- Number of records and size information in a \ref
  Matlab::GAMSTransfer::ConstContainer "ConstContainer" refers to that
  information in the read GDX file and not on the records currently stored in
  the container. This allows to read a GDX file without records and inspect
  symbol sizes and sparsity etc.
- \ref Matlab::GAMSTransfer::ConstContainer "ConstContainer" symbols do not
  offer methods to manage UELs, e.g. \ref Matlab::GAMSTransfer::Symbol::getUELs
  "getUELs", see also \ref MATLAB_GT_DESIGN_UEL.
- Properties supported by \ref Matlab::GAMSTransfer::ConstContainer
  "ConstContainer" symbols only:
  - `symbol_type`: Symbol type, e.g. `set` or `variable`.
  - `number_records`: Number of records in read GDX file, not actually read
    records, see also \ref Matlab::GAMSTransfer::Symbol::getNumberRecords
    "getNumberRecords".
  - `number_values`: Number of values read, which differs to number of records
    due to chosen format, see also \ref
    Matlab::GAMSTransfer::Symbol::getNumberValues "getNumberValues".
  - `sparsity`: Sparsity of symbol based on number of records read and symbol
    shape as in GDX file, see also \ref
    Matlab::GAMSTransfer::Symbol::getSparsity "getSparsity".
  - `uels` (optional): UELs used in symbol if categorical arrays are not
    supported.
- Properties supported by \ref Matlab::GAMSTransfer::Container
  "Container" symbols only:
  - \ref Matlab::GAMSTransfer::Variable::default_values "default_values".
  - \ref Matlab::GAMSTransfer::Symbol::domain_forwarding "domain_forwarding".

\par Advanced users:
Creation of categorical arrays can be a bottleneck. Reading performance can be
increased for a \ref Matlab::GAMSTransfer::ConstContainer "ConstContainer" (not
\ref Matlab::GAMSTransfer::Container "Container") when disabling them:
\code{.matlab}
c = ConstContainer('path/to/file.gdx', 'features', struct('categorical', false));
\endcode
Domain entries are numerical IDs of UELs (see also \ref MATLAB_GT_DESIGN_UEL)
and can be looked up in the `uels` field of a symbol.

\subsection GAMSTRANSFER_MATLAB_RECFORMATS Record Formats

The Matlab version of GAMS Transfer can read and maintain the symbol records in
four different formats: `struct`, `table`, `dense_matrix` and `sparse_matrix`.

Both `struct` and `table` are table-like formats storing the domain entries in
the first \ref Matlab::GAMSTransfer::Symbol::dimension "dimension" columns
followed by value columns (`value` for \ref Matlab::GAMSTransfer::Parameter
"Parameter", `text` for \ref Matlab::GAMSTransfer::Set "Set" and `level`,
`marginal`, `lower`, `upper`, `scale` for \ref Matlab::GAMSTransfer::Variable
"Variable" and \ref Matlab::GAMSTransfer::Equation "Equation") and the records
as rows. Both `dense_matrix` and `sparse_matrix` are matrix-like formats where
the matrices have `max(2,d)` dimensions, where `d` is the symbol \ref
Matlab::GAMSTransfer::Symbol::dimension "dimension", and shape \ref
Matlab::GAMSTransfer::Symbol::size "size". Domain entries cannot be stored in
the matrix, but can be queried using the symbol method \ref
Matlab::GAMSTransfer::Symbol::getUELs "getUELs" (see also \ref
MATLAB_GT_DESIGN_UEL). Assume a symbol `s` has two dimensions. Then, a
`(row,col)` matrix entry corresponds to the domain entry `{s.getUELLabels(1,
row), s.getUELLabels(2, col)}`. The logic is analogue for different dimensions.

Each format has its advantages and disadvantages, see the following table
(ratings `++` (very good), `+`, `o`, `-`, `--`, rated relatively for each
category):

| Record Format | Max Dimension | Efficiency | Memory (General) | Memory (Dense Data) | Display |
|:--------------|:--------------|:-----------|:-----------------|:--------------------|:--------|
| struct        | 20 (GAMS limit)  | `++` | `+`  | `-`  | `-`  |
| table         | 20 (GAMS limit)  | `--` | `o`  | `--` | `++` |
| dense_matrix  | 20 (GAMS limit)  | `+`  | `--` | `++` | `-`  |
| sparse_matrix | 2 (Matlab limit) | `o`  | `++` | `+`  | `--` |

\note For scalar symbols (\ref Matlab::GAMSTransfer::Symbol::dimension
"dimension" equals 0), the formats `struct` and `dense_matrix` are equivalent.
GAMS Transfer will usually prefer `struct` in case of ambiguity.

\note \ref Matlab::GAMSTransfer::Set "Sets" can only be maintained in formats
`struct` and `table`.

\attention Matrix based formats do not store the domain UELs in its own symbol
object. Instead, they are given by the elements of the domain set. This implies
that changing the domain set records (e.g. in its order) will change the meaning
of the matrix formats.

\par Example (`table`):
\code{.matlab}
>> x.records

ans =

  6×7 table

       i_1         j_2       level    marginal    lower    upper    scale
    _________    ________    _____    ________    _____    _____    _____

    seattle      new-york      50          0        0       Inf       1
    seattle      chicago      300          0        0       Inf       1
    seattle      topeka         0      0.036        0       Inf       1
    san-diego    new-york     275          0        0       Inf       1
    san-diego    chicago        0      0.009        0       Inf       1
    san-diego    topeka       275          0        0       Inf       1
\endcode

\par Example (`struct`):
\code{.matlab}
>> x.records

ans =

  struct with fields:

         i_1: [6×1 categorical]
         j_2: [6×1 categorical]
       level: [6×1 double]
    marginal: [6×1 double]
       lower: [6×1 double]
       upper: [6×1 double]
       scale: [6×1 double]

>> x.records.level

ans =

    50
   300
     0
   275
     0
   275
\endcode

\par Example (`dense_matrix`):
\code{.matlab}
>> x.records

ans =

  struct with fields:

       level: [2×3 double]
    marginal: [2×3 double]
       lower: [2×3 double]
       upper: [2×3 double]
       scale: [2×3 double]

>> x.records.level

ans =

    50   300     0
   275     0   275
\endcode

\par Example (`sparse_matrix`):
\code{.matlab}
>> x.records

ans =

  struct with fields:

       level: [2×3 double]
    marginal: [2×3 double]
       lower: [2×3 double]
       upper: [2×3 double]
       scale: [2×3 double]

>> x.records.level

ans =

   (1,1)       50
   (2,1)      275
   (1,2)      300
   (2,3)      275
\endcode
Note that in the above examples the following holds, which can be used to
get the domain entries for matrix elements as described in the beginning of this
section.
\code{.matlab}
x.getUELLabels(1, 1:2) equals {'seattle', 'san-diego'}
x.getUELLabels(2, 1:3) equals {'new-york', 'chicago', 'topeka'}
\endcode

\subsection MATLAB_GT_DESIGN_SV Special Values

GAMS GDX offers five special values: \ref
Matlab::GAMSTransfer::SpecialValues::NA "NA" (not available), \ref
Matlab::GAMSTransfer::SpecialValues::UNDEF "UNDEF" (undefined), \ref
Matlab::GAMSTransfer::SpecialValues::EPS "EPS" (explicit zero, a standard zero
is usually not stored in the sparse GDX format), PINF or \ref
Matlab::GAMSTransfer::SpecialValues::POSINF "POSINF" (positive infinity) and
MINF or \ref Matlab::GAMSTransfer::SpecialValues::NEGINF "NEGINF" (negative
infinity). All special values can be queried and checked for using the class
\ref Matlab::GAMSTransfer::SpecialValues "SpecialValues". While \ref
Matlab::GAMSTransfer::SpecialValues::UNDEF "UNDEF", \ref
Matlab::GAMSTransfer::SpecialValues::POSINF "POSINF" and \ref
Matlab::GAMSTransfer::SpecialValues::NEGINF "NEGINF" have natural counterparts
in Matlab (`NaN`, `Inf` and `-Inf`, respectively), \ref
Matlab::GAMSTransfer::SpecialValues::NA "NA" and \ref
Matlab::GAMSTransfer::SpecialValues::EPS "EPS" do not. The latter two are
therefore mapped to a special `NaN` and `-0`, respectively.

\par Example:
\code{.matlab}
>> a = [0, NaN, SpecialValues.NA, SpecialValues.UNDEF, SpecialValues.EPS, SpecialValues.POSINF, SpecialValues.NEGINF]

a =

     0   NaN   NaN   NaN     0   Inf  -Inf

>> SpecialValues.isNA(a)

ans =

  1×7 logical array

   0   0   1   0   0   0   0

>> SpecialValues.isUndef(a)

ans =

  1×7 logical array

   0   1   0   1   0   0   0

>> SpecialValues.isEps(a)

ans =

  1×7 logical array

   0   0   0   0   1   0   0
\endcode

\subsection MATLAB_GT_DESIGN_UEL Unique Elements (UELs)

A Unique Element (UEL) is an `(i,s)` pair where `i` is an identification number
for a string `s`. GDX uses UELs to efficiently store domain entries of a
record by storing the UEL ID `i` of a domain entry instead of the actual string
`s`. This avoids storing the same string multiple times. The concept of UELs
also exists in Matlab and is called a "categorical array". Hence, GAMS Transfer
uses categorical arrays to store domain entries.

Each symbol maintains its own list of UELs per dimension, which can be accessed
and modified via the methods \ref Matlab::GAMSTransfer::Symbol::getUELs
"getUELs", \ref Matlab::GAMSTransfer::Symbol::setUELs "setUELs", \ref
Matlab::GAMSTransfer::Symbol::initUELs "initUELs", \ref
Matlab::GAMSTransfer::Symbol::addUELs "addUELs", \ref
Matlab::GAMSTransfer::Symbol::removeUELs "removeUELs" and \ref
Matlab::GAMSTransfer::Symbol::renameUELs "renameUELs" (or the Matlab functions
for modifying categorical arrays). The UEL IDs are numbered from 1 to the number
of UELs stored independently for each dimension. It is possible to convert a
categorical array to its IDs by using any number conversion function like
`int64()` in Matlab.

Usually, it is not necessary to explicitly add a UEL with \ref
Matlab::GAMSTransfer::Symbol::addUELs "addUELs". Simply using a new UEL in \ref
Matlab::GAMSTransfer::Symbol::records "records" will add it automatically to the
UEL list. However, it is possible to store more UELs than those actually used in
the \ref Matlab::GAMSTransfer::Symbol::records "records". Advanced users can use
this fact to sort the universe set of a GDX file to their needs.

\attention The methods \ref Matlab::GAMSTransfer::Symbol::setUELs "setUELs" and
\ref Matlab::GAMSTransfer::Symbol::removeUELs "removeUELs" may reassign
different UEL IDs to the UEL labels. These changes are applied to the IDs used
in \ref Matlab::GAMSTransfer::Symbol::records "records". This implies that
removing a UEL that is used in the \ref Matlab::GAMSTransfer::Symbol::records
"records" will then lead to an invalid domain entry (displayed as `<undefined>`
in Matlab). If these updates are not desired, use the method \ref
Matlab::GAMSTransfer::Symbol::initUELs "initUELs" instead.

\note Users with Matlab or Octave versions that do not support categorical
arrays must store the UEL IDs in the domain columns of the \ref
Matlab::GAMSTransfer::Symbol::records "records". Storing strings is not
supported. For looking up the corresponding string, use the method \ref
Matlab::GAMSTransfer::Symbol::getUELLabels "getUELLabels".

\par Example (getting UEL IDs):
\code{.matlab}
>> x.records.i_1'

ans =

  1×6 categorical array

     seattle      seattle      seattle      san-diego      san-diego      san-diego

>> x.records.j_2'

ans =

  1×6 categorical array

     new-york      chicago      topeka      new-york      chicago      topeka

>> x.getUELs(1)'

ans =

  1×2 cell array

    {'seattle'}    {'san-diego'}

>> x.getUELs(2)'

ans =

  1×3 cell array

    {'new-york'}    {'chicago'}    {'topeka'}

>> int64(x.records.i_1)'

ans =

     1     1     1     2     2     2

>> int64(x.records.j_2)'

ans =

  1×6 int64 row vector

   1   2   3   1   2   3
\endcode

\par Example (changing UELs):
\code{.matlab}
>> x.setUELs(1, {'madison', 'new-york', 'seattle'});
>> categories(x.records.i_1)

ans =

  3×1 cell array

    {'madison' }
    {'new-york'}
    {'seattle' }

>> x.records.i_1'

ans =

  1×6 categorical array

     seattle      seattle      seattle      <undefined>      <undefined>      <undefined>
\endcode

\par Example (adding UELs via records):
\code{.matlab}
>> x.records.i_1(end) = "houston";
>> categories(x.records.i_1)

ans =

  4×1 cell array

    {'madison' }
    {'new-york'}
    {'seattle' }
    {'houston' }

>> x.records.i_1'

ans =

  1×6 categorical array

     seattle      seattle      seattle      <undefined>      <undefined>      houston
\endcode

\section MATLAB_GT_GDX Data Exchange With GDX

\subsection GAMSTRANSFER_MATLAB_READ Reading Data From GDX

For reading a GDX file, the file path can be specified when constructing a
\ref Matlab::GAMSTransfer::Container "Container". This will read the whole GDX
file. For more control over the read procedure, use the \ref
Matlab::GAMSTransfer::Container::read "read" method. It is possible to only read
a subset of the symbols in the GDX file or to specify the format to read in. The
method (optional) arguments are:
- `symbols`: List of symbol names to be read. All if empty list.
- `format`: \ref MATLAB_GT_DESIGN_REC_FORMATS "Records format" to read records
  in.
- `values`: Subset of `{'level', 'marginal', 'lower', 'upper', 'scale'}` to
  specify which of those values should be read.

Furthermore, instead of a GDX file \ref Matlab::GAMSTransfer::Container
"Container" can read from a \ref Matlab::GAMSTransfer::ConstContainer
"ConstContainer".

\attention When reading from different GDX files it can happen that two different symbols
have the same name. It is currently not possible to rename a symbol on load or
to merge symbol contents, for example. GAMS Transfer will simply raise an error.

\note Changing the GDX file name of a \ref Matlab::GAMSTransfer::Container
"Container" and/or reading from multiple GDX files into the same container is
not supported.

\par Example (full read with constructor):
\code{.matlab}
m = Container('path/to/file.gdx');
\endcode

\par Example (full read with read method):
\code{.matlab}
m = Container();
m.read('path/to/file.gdx');
\endcode

\par Example (partial read):
To read all records from symbols `x` and `c` as `dense_matrix`, but only `level`
values for `d` in `struct` format, call:
\code{.matlab}
m = Container();
m.read('path/to/file.gdx', 'symbols', {'x', 'c'}, 'format', 'dense_matrix');
m.read('path/to/file.gdx', 'symbols', {'d'}, 'format', 'struct', 'values', {'level'});
\endcode

\par Example (read from ConstContainer):
\code{.matlab}
mc = ConstContainer('path/to/file.gdx');
m1 = Container(mc);
m2 = Container();
m2.read(mc);
\endcode

\subsection MATLAB_GT_ACCESS Accessing Data

Symbols are stored in the struct \ref Matlab::GAMSTransfer::Container::data
"data" of the \ref Matlab::GAMSTransfer::Container "Container", with fieldnames
equal to the symbol names. Within the symbol, symbol records are located in the
table or struct (depending on the \ref MATLAB_GT_DESIGN_REC_FORMATS) \ref
Matlab::GAMSTransfer::Symbol::records "records". Further to accessing \ref
Matlab::GAMSTransfer::Container::data "data" directly, symbol handle lists can
be queried via the method \ref Matlab::GAMSTransfer::Container::getSymbols
"getSymbols" given a list of symbol names. This can be particularly useful in
combination with the functions \ref Matlab::GAMSTransfer::Container::listSymbols
"listSymbols", \ref Matlab::GAMSTransfer::Container::listSets "listSets", \ref
Matlab::GAMSTransfer::Container::listAliases "listAliases", \ref
Matlab::GAMSTransfer::Container::listParameters "listParameters", \ref
Matlab::GAMSTransfer::Container::listVariables "listVariables" and \ref
Matlab::GAMSTransfer::Container::listEquations "listEquations" that list the
names of symbols of the corresponding type.

\par Example:
\code{.matlab}
>> m.data

ans =

  struct with fields:

         i: [1×1 GAMSTransfer.Set]
         j: [1×1 GAMSTransfer.Set]
         a: [1×1 GAMSTransfer.Parameter]
         b: [1×1 GAMSTransfer.Parameter]
         d: [1×1 GAMSTransfer.Parameter]
         f: [1×1 GAMSTransfer.Parameter]
         c: [1×1 GAMSTransfer.Parameter]
         x: [1×1 GAMSTransfer.Variable]
         z: [1×1 GAMSTransfer.Variable]
      cost: [1×1 GAMSTransfer.Equation]
    supply: [1×1 GAMSTransfer.Equation]
    demand: [1×1 GAMSTransfer.Equation]

>> m.listVariables()'

ans =

  1×2 cell array

    {'x'}    {'z'}

>> vars = m.getSymbols(m.listVariables())'

vars =

  1×2 cell array

    {1×1 GAMSTransfer.Variable}    {1×1 GAMSTransfer.Variable}

>> {vars{1}.name, vars{2}.name}

ans =

  1×2 cell array

    {'x'}    {'z'}
\endcode

\subsection GAMSTRANSFER_MATLAB_WRITE Writing Data To GDX

The current \ref Matlab::GAMSTransfer::Container "Container" with all its
symbols and symbol records can be written to a GDX file using the \ref
Matlab::GAMSTransfer::Container::write "write" method. It is possible to write
the GDX file in compressed format by setting the method argument `compress` to
`true`.

\note It is not possible to write the \ref Matlab::GAMSTransfer::Container
"Container" when any of its symbols is not valid (see also \ref
MATLAB_GT_ANALYZE_CHECK). A symbol can be considered valid but still has domain
violations, which would lead to an error when writing, see also \ref
MATLAB_GT_ANALYZE_DOMVIOL.

\par Example:
\code{.matlab}
m.write('path/to/file.gdx');
\endcode

\par Example (write compressed GDX):
\code{.matlab}
m.write('path/to/file.gdx', 'compress', true);
\endcode

\par Advanced users:
GDX expects the symbol records to be sorted in a certain order. Since this can
be difficult for the user to achieve, the records are sorted (without
overwriting) on default when writing to GDX. Users who know that their symbol
records are sorted correctly, can set the \ref
Matlab::GAMSTransfer::Container::write "write" method argument `sorted` to
`true` in order to improve efficiency. Symbol records `dense_matrix` and
`sparse_matrix` are sorted per definition (`sorted` has no effect). GDX expects
the following order for `struct` and `table` formats. Symbol records are sorted
by domain UEL IDs (see also \ref MATLAB_GT_DESIGN_UEL) in ascending order first
w.r.t. dimension 1, then 2, etc. However, UEL IDs are here not relative to the
symbol as described in \ref MATLAB_GT_DESIGN_UEL, but global to the whole
container where only the first occurence is relevant. In result, symbol order
implies UEL order and hence symbol record order. The method \ref
Matlab::GAMSTransfer::Container::getUniverseSet "getUniverseSet" returns this
global UEL ordering.

<!-- MATLAB_GT_ADD_MODIFY headline is used within text; check text when updating -->
\section MATLAB_GT_ADD_MODIFY Adding and Modifying Data

\subsection MATLAB_GT_ADD_MODIFY_ADD Adding Symbols

Two equivalent ways of adding a symbol to the \ref
Matlab::GAMSTransfer::Container "Container" exist:
- \ref Matlab::GAMSTransfer::Container "Container" methods \ref
  Matlab::GAMSTransfer::Container::addSet "addSet", \ref
  Matlab::GAMSTransfer::Container::addAlias "addAlias", \ref
  Matlab::GAMSTransfer::Container::addParameter "addParameter", \ref
  Matlab::GAMSTransfer::Container::addVariable "addVariable" and \ref
  Matlab::GAMSTransfer::Container::addEquation "addEquation".
- \ref Matlab::GAMSTransfer::Symbol "Symbol" constructors \ref
  Matlab::GAMSTransfer::Set::Set "Set", \ref
  Matlab::GAMSTransfer::Alias::Alias "Alias", \ref
  Matlab::GAMSTransfer::Parameter::Parameter "Parameter", \ref
  Matlab::GAMSTransfer::Variable::Variable "Variable" and \ref
  Matlab::GAMSTransfer::Equation::Equation "Equation".

The following table lists the possible arguments that are needed or possible for
defining the symbol. Here, the argument can be either of type `required`,
`optional` (argument is positional but not required) or `parameter` (argument
name and value have to be passed as pair, argument is not required). A `#`
indicates the position if the argument is positional and the value in brackets
is the default value if the argument is not required.

| Argument | Type | Description| Set | Alias | Parameter | Variable | Equation |
|:---------|:-----|:-----------|:----|:------|:----------|:---------|:---------|
| \ref Matlab::GAMSTransfer::Symbol::name "name" | string | Name of symbol | required #1 | required #1 | required #1 | required #1 | required #1 |
| \ref Matlab::GAMSTransfer::Alias::alias_with "alias_with" | \ref Matlab::GAMSTransfer::Set "Set" | Set an alias is linked to | - | required #2 | - | - | - |
| \ref Matlab::GAMSTransfer::Variable::type "type" | string, int | Variable or Equation type, see \ref Matlab::GAMSTransfer::VariableType "VariableType" and \ref Matlab::GAMSTransfer::EquationType "EquationType" | - | - | - | optional #2 ('free') | required #2 |
| \ref Matlab::GAMSTransfer::Symbol::domain "domain" | cell, \ref Matlab::GAMSTransfer::Set "Set", string | List of domains given either as string ('*' for universe set) or as reference to a \ref Matlab::GAMSTransfer::Set "Set" object | optional #2 ('*') | - | optional #2 ({}) | optional #3 ({}) | optional #3 ({}) |
| \ref Matlab::GAMSTransfer::Symbol::description "description" | string | Description of symbol | parameter ('') | - | parameter ('') | parameter ('') | parameter ('') |
| \ref Matlab::GAMSTransfer::Symbol::records "records" | any | Symbol records, see also \ref MATLAB_GT_ADD_MODIFY_RECORDS | parameter ([]) | - | parameter ([]) | parameter ([]) | parameter ([]) |
| \ref Matlab::GAMSTransfer::Set::is_singleton "is_singleton" | logical | Indicates if set is a singleton set (true) or not (false) | parameter (false) | - | - | - | - |

The other symbol properties are implied by those listed above. For example, \ref
Matlab::GAMSTransfer::Symbol::dimension "dimension" is the number of elements in
\ref Matlab::GAMSTransfer::Symbol::domain "domain". All the above symbol
properties can be modified at any time after the addition to the container.
Furthermore, changing the property \ref Matlab::GAMSTransfer::Symbol::dimension
"dimension" has the following effect: Decreasing the \ref
Matlab::GAMSTransfer::Symbol::dimension "dimension" will remove \ref
Matlab::GAMSTransfer::Symbol::domain "domain" elements at the back, while
increasing the \ref Matlab::GAMSTransfer::Symbol::dimension "dimension" will
append appropriately many universe set domains `*`. Changing symbol properties
may cause reevaluation of validity once an operation requires this changed
symbol to be valid.

\note If any domain element is passed as string except for `*` (universe
set), the domain is handled `relaxed` instead of `regular` as indicated by the
property \ref Matlab::GAMSTransfer::Symbol::domain_type "domain_type". This
means that domain checking does not apply, see also \ref
MATLAB_GT_ANALYZE_DOMVIOL.

\par Example (using container methods):
\code{.matlab}
m = Container();
i = m.addSet('i', 'records', {'seattle', 'san-diego'}, 'description', 'canning plants');
a = m.addParameter('a', i, 'records', [350, 600], 'description', 'capacity of plant i in cases');
supply = m.addEquation('supply', 'l', i, ...
    'records', struct('level', [350, 550], 'marginal', [SpecialValues.EPS, 0], 'upper', [350, 600]), ...
    'description', 'observe supply limit at plant i');
\endcode

\par Example (using symbol constructors):
See also the introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
m = Container();
i = Set(m, 'i', 'records', {'seattle', 'san-diego'}, 'description', 'canning plants');
a = Parameter(m, 'a', i, 'records', [350, 600], 'description', 'capacity of plant i in cases');
supply = Equation(m, 'supply', 'l', i, ...
    'records', struct('level', [350, 550], 'marginal', [SpecialValues.EPS, 0], 'upper', [350, 600]), ...
    'description', 'observe supply limit at plant i');
\endcode

\subsection MATLAB_GT_ADD_MODIFY_RECORDS Assigning Symbol Records

Three possibilities exist to assign symbol records to a symbol:
- Setting the property \ref Matlab::GAMSTransfer::Symbol::records "records".
- Using the symbol method \ref Matlab::GAMSTransfer::Symbol::setRecords
  "setRecords".
- Setting the argument `records` in a symbol constructor (internally calls \ref
  Matlab::GAMSTransfer::Symbol::setRecords "setRecords").

If data is assigned to the \ref Matlab::GAMSTransfer::Symbol::records "records"
property directly, the user is in charge to format the data in any of the
supported \ref MATLAB_GT_DESIGN_REC_FORMATS. If the user fails to do so, the
symbol will be marked as invalid, see also \ref MATLAB_GT_ANALYZE_CHECK. The
method \ref Matlab::GAMSTransfer::Symbol::setRecords "setRecords" is a
convenience method that transforms the given data either into the `struct`,
`dense_matrix` or `sparse_matrix` format (e.g., depending on if the user
supplies domain entries or not). The following transformations are supported:
- `string`: Interpreted as domain entry for first dimension.
- `cellstr`: First dimension of cellstr must be equal to symbol dimension and
  second will be the number of records. Row `i` is interpreted to hold the
  domain entries for dimension `i`.
- `numeric vector/matrix`: Interpreted to hold the `level` values (or `value`
  for Parameter). Must satisfy the shape given by symbol size since this can
  only be a matrix format (e.g. `dense_matrix` or `sparse_matrix`), because
  domain entries are not given.
- `cell`: If element is the `i`-th cellstr, then this is considered to be the
  domain entries for the `i`-th domain. If element is the `j`-th numeric
  vector/matrix, it is interpreted as the `j`-th element of the following: (1)
  `level` or `value`, (2) `marginal`, (3) `lower`, (4) `upper`, (5) `scale`. If
  symbol is a Set, the `(dim+1)`-th cellstr is considered to be the set element
  texts.
- `struct`: Fields which names match domain labels, are interpreted as domain
  entries of the corresponding domain. Other supported fields are `level`,
  `value`, `marginal`, `lower`, `upper`, `scale`, `text`. Unsopprted fields are
  ignored.
- `table`: used as is, but checked for correctness.

\note Instead of a `cell`, it is possible to provide the elements as separate
arguments to the method \ref Matlab::GAMSTransfer::Symbol::setRecords
"setRecords".

\par Example (single string)
Consider the symbol `a` to be a 1-dim parameter with domain `i`, see the
introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> a.setRecords('seattle');
>> a.transformRecords('table'); % format was struct
>> a.records

ans =

  table

      i_1
    _______

    seattle
\endcode

\par Example (strings)
Consider the symbol `a` to be a 1-dim parameter with domain `i`, see the
introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> a.setRecords({'seattle', 'san-diego'});
>> a.transformRecords('table'); % format was struct
>> a.records

ans =

  2×1 table

       i_1
    _________

    seattle
    san-diego
\endcode

\par Example (numeric vector)
Consider the symbol `a` to be a 1-dim parameter with domain `i`, see the
introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> a.setRecords([300 400]);
>> a.transformRecords('table'); % format was dense_matrix
>> a.records

ans =

  2×2 table

       i_1       value
    _________    _____

    seattle       300
    san-diego     400
\endcode

\par Example (numeric vectors)
Consider the symbol `v` to be a 1-dim variable with domain `i`, where `i` is
defined in the introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> v.setRecords([1 2], [11 22], [111 222], [1111 2222]);
>> v.transformRecords('table'); % format was dense_matrix
>> v.records

ans =

  2×5 table

       i_1       level    marginal    lower    upper
    _________    _____    ________    _____    _____

    seattle        1         11        111     1111
    san-diego      2         22        222     2222
\endcode

\par Example (cell)
Consider the symbol `x` to be a 2-dim variable with domain `{i,j}`, see the
introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> x.setRecords({'seattle', 'seattle'}, {'new-york', 'chicago'}, [1 2], [11 22], [111 222], [1111 2222]);
>> x.transformRecords('table'); % format was struct
>> x.records

ans =

  2×6 table

      i_1        j_2       level    marginal    lower    upper
    _______    ________    _____    ________    _____    _____

    seattle    new-york      1         11        111     1111
    seattle    chicago       2         22        222     2222
\endcode

\subsection MATLAB_GT_ADD_MODIFY_REMOVE Removing Symbols

To remove a symbol from the \ref Matlab::GAMSTransfer::Container "Container",
simply call the method \ref Matlab::GAMSTransfer::Container::removeSymbols
"removeSymbols".

\attention If a \ref Matlab::GAMSTransfer::Set "Set" is removed from the \ref
Matlab::GAMSTransfer::Container "Container", a handle to that \ref
Matlab::GAMSTransfer::Set "Set" can still exist as a domain of another symbol or
be linked to by an alias. This will make these other symbols invalid, see \ref
Matlab::GAMSTransfer::Symbol::isValid "isValid".

\par Example:
\code{.matlab}
>> m.removeSymbols('x');
>> m.removeSymbols({'a', 'b'});
\endcode

\subsection MATLAB_GT_ADD_MODIFY_REORDER Reordering Symbols

The GDX file requires the symbols to be sorted such that, for example, a \ref
Matlab::GAMSTransfer::Set "Set" used as domain of another symbol appears before
that symbol. The \ref Matlab::GAMSTransfer::Container "Container" will try to
establish a valid ordering when writing the data to GDX. However, this operation
can also be invoked manually by calling the method \ref
Matlab::GAMSTransfer::Container::reorderSymbols "reorderSymbols".

\section GAMSTRANSFER_MATLAB_ANALYZE Analyzing Data

\subsection MATLAB_GT_ANALYZE_DESCRIBE Data Overview

The methods \ref Matlab::GAMSTransfer::Container::describeSets "describeSets",
\ref Matlab::GAMSTransfer::Container::describeAliases "describeAliases", \ref
Matlab::GAMSTransfer::Container::describeParameters "describeParameters", \ref
Matlab::GAMSTransfer::Container::describeVariables "describeVariables" and \ref
Matlab::GAMSTransfer::Container::describeEquations "describeEquations" allow for
an overview over the symbols of the corresponding type stored in the \ref
Matlab::GAMSTransfer::Container "Container". These methods return a table
listing for each symbol the properties / statistics given in the following table
(here an `x` means that this property / statistic is available for the symbol
type and note that `*_level` is called `*_value` or simply `*` for \ref
Matlab::GAMSTransfer::Parameter "Parameter").

| Property / Statistic | Description | Set | Alias | Parameter | Variable | Equation |
|:---------------------|:------------|:----|:------|:----------|:---------|:---------|
| name | \ref Matlab::GAMSTransfer::Symbol::name "Name" of symbol | x | x | x | x | x |
| is_alias | Indicates if set is an alias (true) or not (false) | x | x |  |  |  |
| is_singleton | Indicates if set is a singleton set (true) or not (false) | x | x |  |  |  |
| alias_with | Set an alias is linked to |  | x |  |  |  |
| type | Variable or Equation type, see \ref Matlab::GAMSTransfer::VariableType "VariableType" and \ref Matlab::GAMSTransfer::EquationType "EquationType" |  |  |  | x | x |
| format | Format \ref Matlab::GAMSTransfer::Symbol::records "records" are stored in, see \ref MATLAB_GT_DESIGN_REC_FORMATS | x | x | x | x | x |
| dim | \ref Matlab::GAMSTransfer::Symbol::dimension "Dimension" of symbol | x | x | x | x | x |
| domain_type | Type of domain, e.g. relaxed or regular | x | x | x | x | x |
| domain | \ref Matlab::GAMSTransfer::Symbol::domain "Domain" of symbol | x | x | x | x | x |
| size | \ref Matlab::GAMSTransfer::Symbol::size "Size" or shape of symbol | x | x | x | x | x |
| num_recs | Number of symbol GDX \ref Matlab::GAMSTransfer::Symbol::records "records" | x | x | x | x | x |
| num_vals | Number of stored \ref Matlab::GAMSTransfer::Symbol::records "records" values | x | x | x | x | x |
| sparsity | Sparsity of symbol \ref Matlab::GAMSTransfer::Symbol::records "records" w.r.t. to count | x | x | x | x | x |
| min_level | Minimum value of level values |  |  | x | x | x |
| mean_level | Mean value of level values |  |  | x | x | x |
| max_level | Maximum value of level values |  |  | x | x | x |
| where_max_abs_level | Domain entry of record with maximum absolute level value |  |  | x | x | x |
| count_na_level | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::NA "NA" in level values |  |  | x | x | x |
| count_undef_level | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::UNDEF "UNDEF" in level values |  |  | x | x | x |
| count_eps_level | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::EPS "EPS" in level values |  |  | x | x | x |
| min_marginal | Minimum value of marginal values |  |  |  | x | x |
| mean_marginal | Mean value of marginal values |  |  |  | x | x |
| max_marginal | Maximum value of marginal values |  |  |  | x | x |
| where_max_abs_marginal | Domain entry of record with maximum absolute marginal value |  |  |  | x | x |
| count_na_marginal | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::NA "NA" in marginal values |  |  |  | x | x |
| count_undef_marginal | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::UNDEF "UNDEF" in marginal values |  |  |  | x | x |
| count_eps_marginal | Number of GAMS special values \ref Matlab::GAMSTransfer::SpecialValues::EPS "EPS" in marginal values |  |  |  | x | x |

\par Example:
\code{.matlab}
>> tbl = m.describeVariables();
>> tbl(:,1:10)

ans =

  2×10 table

    name      type      format    dim    domain_type    domain    size     num_recs    num_vals    sparsity
    ____    ________    ______    ___    ___________    ______    _____    ________    ________    ________

     x      positive    table      2       regular      [i,j]     [2,3]       6           12         0.6
     z      free        struct     0       none         []        []          1            1         0.8

>> tbl(:,11:17)

ans =

  2×7 table

    min_level    mean_level    max_level    where_max_abs_level    count_na_level    count_undef_level    count_eps_level
    _________    __________    _________    ___________________    ______________    _________________    _______________

          0           150          300       [seattle,chicago]           0                   0                   0
     153.68        153.68       153.68       []                          0                   0                   0

>> tbl(:,18:24)

ans =

  2×7 table

    min_marginal    mean_marginal    max_marginal    where_max_abs_marginal    count_na_marginal    count_undef_marginal    count_eps_marginal
    ____________    _____________    ____________    ______________________    _________________    ____________________    __________________

          0            0.0075           0.036           [seattle,topeka]               0                     0                      0
        NaN               NaN             NaN           <undefined>                    0                     0                      0
\endcode

\subsection MATLAB_GT_ANALYZE_DOMVIOL Handle Domain Violations

Domain violations occur when a symbol uses other \ref Matlab::GAMSTransfer::Set
"Set"(s) as \ref Matlab::GAMSTransfer::Symbol::domain "domain"(s) and a domain
entry in its \ref Matlab::GAMSTransfer::Symbol::records "records" that is not
present in the corresponding set. Such a domain violation will lead to a GDX
error when writing the data. The method \ref
Matlab::GAMSTransfer::Symbol::getDomainViolations "getDomainViolations" returns
a list of \ref Matlab::GAMSTransfer::DomainViolation "DomainViolation" objects
w.r.t. each dimension of the symbol which can be used to resolve the domain
violations. The GAMS Transfer methods \ref
Matlab::GAMSTransfer::Symbol::resolveDomainViolations "resolveDomainViolations"
and \ref Matlab::GAMSTransfer::DomainViolation::resolve "resolve" offer an
automatic expansion of the domain sets with the violated entries in order to
eliminate domain violations. This resolving feature can further be triggered
automatically by setting the symbol property \ref
Matlab::GAMSTransfer::Symbol::domain_forwarding "domain_forwarding" to `true`. If \ref
Matlab::GAMSTransfer::Symbol::records "records" are updated by direct access,
the domain update will happen delayed for improved efficiency, but can be forced
by calling \ref Matlab::GAMSTransfer::Symbol::isValid "isValid" or the resolving
methods mentioned above.

\note The method for automatically resolving the domain violations can be
convenient, but it effectively disables domain checking, which is a valuable
tool for error detection. We encourage to use \ref
Matlab::GAMSTransfer::Symbol::resolveDomainViolations "resolveDomainViolations",
\ref Matlab::GAMSTransfer::DomainViolation::resolve "resolve" or \ref
Matlab::GAMSTransfer::Symbol::domain_forwarding "domain_forwarding" enabled as rarely as
possible. The same holds for using `relaxed` domain information when `regular`
domain information would be possible, see \ref
Matlab::GAMSTransfer::Symbol::domain_type "domain_type".

\par Example (domain violation when writing):
Consider the symbol `x` to have domains `{i,j}`, where `i` and `j` are \ref
Matlab::GAMSTransfer::Set "Sets". The label `madison` is not part of set `i`.
See \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> x.records.i_1(end) = "madison";
>> i.records.uni_1'

ans =

  1×2 categorical array

     seattle      san-diego

>> m.write();
Error using gt_gdx_write
GDX error in record x(madison,topeka): Domain violation

Error in GAMSTransfer.Container/write (line 341)
                GAMSTransfer.gt_gdx_write(obj.system_directory, filename, obj.data, ...
\endcode

\par Example (automatically resolving domain violations):
Consider the symbol `x` to have domains `{i,j}`, where `i` and `j` are \ref
Matlab::GAMSTransfer::Set "Sets". The label `madison` is not part of set `i` (in
the beginning). See \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> x.records.i_1(end) = "madison";
>> i.records.uni_1'

ans =

  1×2 categorical array

     seattle      san-diego

>> dv = x.getDomainViolations();
>> dv{1}

ans =

  DomainViolation with properties:

        symbol: [1×1 GAMSTransfer.Variable]
     dimension: 1
        domain: [1×1 GAMSTransfer.Set]
    violations: {'madison'}

>> x.resolveDomainViolations();
>> dv = x.getDomainViolations()

dv =

  0×0 empty cell array

>> i.records.uni_1'

ans =

  1×3 categorical array

     seattle      san-diego      madison
\endcode

\subsection MATLAB_GT_ANALYZE_CHECK Validate Symbol Records

GAMS Transfer requires the symbol records to be stored in one of the supported
\ref MATLAB_GT_DESIGN_REC_FORMATS in order to understand and write them to GDX.
However, it can easily happen that a certain criteria of the format is not met
and the symbol is marked as invalid, i.e., the symbol method \ref
Matlab::GAMSTransfer::Symbol::isValid "isValid" returns `false`. In that case
setting the argument `verbose` of \ref Matlab::GAMSTransfer::Symbol::isValid
"isValid" to `true` will print the reason for invalidity and can thus help to
resolve the issue.

\note Performance hint: In case symbol records are updated within a loop, try to
avoid checking the symbol validity within the loop. Note that symbol methods to
query, for example, the number of records will call \ref
Matlab::GAMSTransfer::Symbol::isValid "isValid" internally.

\par Example (incorrect shape of value field):
Consider variable `x` to be as in the introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> x.transformRecords('struct');
>> x.isValid(true)

ans =

  logical

   1

>> x.records.level = x.records.level';
>> x.isValid(true)
Warning: Value fields must all have the same size.
> In GAMSTransfer/Symbol/isValid (line 840)

ans =

  logical

   0

>> x.records.marginal = x.records.marginal';
>> x.isValid(true)
Warning: Fields need to match matrix format or to be dense column vectors.
> In GAMSTransfer/Symbol/isValid (line 840)

ans =

  logical

   0
\endcode

\par Example (incorrect value field name):
Consider variable `x` to be as in the introductory \ref MATLAB_GT_EXAMPLE.
\code{.matlab}
>> x.transformRecords('struct');
>> x.isValid(true)

ans =

  logical

   1

>> x.records.LEVEL = x.records.level;
>> x.isValid(true)
Warning: Field 'LEVEL' not allowed.
> In GAMSTransfer/Symbol/isValid (line 840)

ans =

  logical

   0
\endcode

*/
